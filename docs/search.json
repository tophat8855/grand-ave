[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Grand Ave, Oakland",
    "section": "",
    "text": "1 Grand Ave, Oakland, CA\nThe City of Oakland is currently looking re-paving Grand Ave, and the local neighborhoods and street safety groups are hoping that the re-paving will also include upgrades in the pedestrian and bicycle infrastructure so that more neighbors are not lost on this street.\nLet’s look at Grand Ave, from Harrison to Mandana.\nSLIDE GRAND AVE CRASH MAP\nSLIDE What are cars crashing into?\nTypes of crashes since 2016\nTypes of crashes over time\nSLIDE HEATMAP OF GRAND AVE INJURIES\nThis is ped and bike only\nthis is ped and bike only",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#heatmap-of-telegraph-ave-crashes",
    "href": "index.html#heatmap-of-telegraph-ave-crashes",
    "title": "Grand Ave, Oakland",
    "section": "2.1 Heatmap of Telegraph Ave crashes",
    "text": "2.1 Heatmap of Telegraph Ave crashes\n\n(kind/hiccup\n [:div [:script\n        {:src \"https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.min.js\"}]\n  ['(fn [latlngs]\n      [:div\n       {:style {:height \"500px\"}\n        :ref   (fn [el]\n                 (let [m (-&gt; js/L\n                             (.map el)\n                             (.setView (clj-&gt;js [37.821925 -122.266376])\n                                       14.3))]\n                   (-&gt; js/L\n                       .-tileLayer\n                       (.provider \"Stadia.AlidadeSmooth\")\n                       (.addTo m))\n                   (doseq [latlng latlngs]\n                     (-&gt; js/L\n                         (.marker (clj-&gt;js latlng))\n                         (.addTo m)))\n                   (-&gt; js/L\n                       (.heatLayer (clj-&gt;js latlngs)\n                                   (clj-&gt;js {:radius 30}))\n                       (.addTo m))))}])\n   telegraph-ave-crash-to-heatmaps]]\n ;; Note we need to mention the dependency:\n {:html/deps [:leaflet]})\n\n\n\n(def telegraph-ave-crashes-with-peds-and-cyclists\n  (-&gt; telegraph-ave-crashes\n      (tc/select-rows (fn [row]\n                        (ped-and-bike-codes (:motor-vehicle-involved-with-code row))))))\n\n\n(def telegraph-ave-injured\n  (let [collision-ids             (-&gt; telegraph-ave-crashes-with-peds-and-cyclists\n                                     (tc/select-columns :collision-id)\n                                     (tc/rows)\n                                     flatten\n                                     set)\n        all-injured-on-telegraph  (-&gt; (load-and-combine-csvs injured-witness-passengers-csv-files)\n                                     (ds/select-columns [:collision-id\n                                                         :injured-wit-pass-id\n                                                         :stated-age\n                                                         :gender\n                                                         :injured-person-type])\n                                     (tc/select-rows (fn [row]\n                                                       (contains? collision-ids (:collision-id row)))))\n        possible-types            (-&gt; all-injured-on-telegraph\n                                     (tc/select-columns :injured-person-type)\n                                     (tc/rows)\n                                     flatten\n                                     set)\n        telegraph-with-crash-data (-&gt; telegraph-ave-crashes-with-peds-and-cyclists\n                                      (tc/select-columns [:collision-id\n                                                          :crash-date-time\n                                                          :motor-vehicle-involved-with-code\n                                                          :motor-vehicle-involved-with-desc\n                                                          :motor-vehicle-involved-with-other-desc\n                                                          :number-injured\n                                                          :number-killed\n                                                          :lighting-description\n                                                          :latitude\n                                                          :longitude\n                                                          :primary-road\n                                                          :secondary-road]))\n        crashes                   (-&gt; all-injured-on-telegraph\n                                     (tc/select-rows (fn [row] (contains? #{\"Pedestrian\" \"Bicyclist\" \"Other\"} (:injured-person-type row))))\n                                     (tc/inner-join telegraph-with-crash-data\n                                                    {:left  :collision-id\n                                                     :right :collision-id}))]\n    (-&gt; crashes\n        (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            telegraph-intersections-of-interest)]\n                            (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            telegraph-intersections-of-interest)]\n                            (:lng match)))))))\n\n\n(def telegraph-ave-injuries-to-heatmaps\n  (mapv (fn [{:keys [intersection-lat intersection-lng row-count]}]\n          [intersection-lat intersection-lng (* 2 row-count)])\n        (-&gt; telegraph-ave-injured\n            (tc/group-by [:intersection-lat :intersection-lng])\n            (tc/aggregate {:row-count tc/row-count})\n            (tc/rows :as-maps))))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#heatmap-of-telegraph-ave-injuries",
    "href": "index.html#heatmap-of-telegraph-ave-injuries",
    "title": "Grand Ave, Oakland",
    "section": "2.2 Heatmap of Telegraph Ave Injuries",
    "text": "2.2 Heatmap of Telegraph Ave Injuries\n\n(kind/hiccup\n [:div [:script\n        {:src \"https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.min.js\"}]\n  ['(fn [latlngs]\n      [:div\n       {:style {:height \"500px\"}\n        :ref   (fn [el]\n                 (let [m (-&gt; js/L\n                             (.map el)\n                             (.setView (clj-&gt;js [37.821925 -122.266376])\n                                       14.3))]\n                   (-&gt; js/L\n                       .-tileLayer\n                       (.provider \"Stadia.AlidadeSmooth\")\n                       (.addTo m))\n                   (doseq [latlng latlngs]\n                     (-&gt; js/L\n                         (.marker (clj-&gt;js latlng))\n                         (.addTo m)))\n                   (-&gt; js/L\n                       (.heatLayer (clj-&gt;js latlngs)\n                                   (clj-&gt;js {:radius 30}))\n                       (.addTo m))))}])\n   telegraph-ave-injuries-to-heatmaps]]\n ;; Note we need to mention the dependency:\n {:html/deps [:leaflet]})",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#injuries-in-oakland-over-time-including-telegraph-by-month",
    "href": "index.html#injuries-in-oakland-over-time-including-telegraph-by-month",
    "title": "Grand Ave, Oakland",
    "section": "2.3 Injuries in Oakland, over time (Including Telegraph), by month",
    "text": "2.3 Injuries in Oakland, over time (Including Telegraph), by month\n\n(-&gt; oakland-city-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :month-year (str (.getYear date-time) \"-\" (.getMonthValue date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :month-year\n      :=y :number-injured}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#injuries-on-telegraph-over-time-by-month",
    "href": "index.html#injuries-on-telegraph-over-time-by-month",
    "title": "Grand Ave, Oakland",
    "section": "2.4 Injuries on Telegraph, over time, by month",
    "text": "2.4 Injuries on Telegraph, over time, by month\n\n(-&gt; telegraph-ave-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :month-year (str (.getYear date-time) \"-\" (.getMonthValue date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :month-year\n      :=y :number-injured}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#injuries-in-oakland-over-time-by-year",
    "href": "index.html#injuries-in-oakland-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.5 Injuries in Oakland, over time, by year",
    "text": "2.5 Injuries in Oakland, over time, by year\n\n(-&gt; oakland-city-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by :year)\n    (tc/aggregate {:number-injured-sum #(reduce + (map (fn [v] (if (nil? v) 0 (Integer. v))) (% :number-injured)))})\n    (plotly/layer-bar\n     {:=x :$group-name\n      :=y :number-injured-sum\n      :=layout {:title \"Number of Injuries Over Years\"\n                :xaxis {:title \"Year\"}\n                :yaxis {:title \"Number of Injuries\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#injuries-on-telegraph-over-time-by-year",
    "href": "index.html#injuries-on-telegraph-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.6 Injuries on Telegraph, over time, by year",
    "text": "2.6 Injuries on Telegraph, over time, by year\n\n(-&gt; telegraph-ave-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by :year)\n    (tc/aggregate {:number-injured-sum #(reduce + (map (fn [v] (if (nil? v) 0 (Integer. v))) (% :number-injured)))})\n    (plotly/layer-bar\n     {:=x :$group-name\n      :=y :number-injured-sum\n      :=layout {:title \"Number of Injuries Over Years\"\n                :xaxis {:title \"Year\"}\n                :yaxis {:title \"Number of Injuries\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#injuries-in-kono-over-time-by-year",
    "href": "index.html#injuries-in-kono-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.7 Injuries in KONO, over time, by year",
    "text": "2.7 Injuries in KONO, over time, by year\n\n(def kono-crashes\n  (let [crashes (-&gt; oakland-city-crashes\n                     (ds/filter #(clojure.string/includes? (or (:primary-road %)\n                                                               (:secondary-road %)) \"TELEGRAPH\"))\n                     (ds/filter (fn [row]\n                                  (or (some #(clojure.string/includes? (:primary-road row) %)\n                                            (keys kono-intersections-of-interest))\n                                      (some #(clojure.string/includes? (:secondary-road row) %)\n                                            (keys kono-intersections-of-interest))))))]\n    (-&gt; crashes\n    (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                           (let [match (some (fn [[k v]]\n                                               (when (clojure.string/includes? secondary-road k)\n                                                 v))\n                                            kono-intersections-of-interest)]\n                             (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                           (let [match (some (fn [[k v]]\n                                               (when (clojure.string/includes? secondary-road k)\n                                                 v))\n                                            kono-intersections-of-interest)]\n                             (:lng match)))))))\n\n\n(-&gt; kono-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by :year)\n    (tc/aggregate {:number-injured-sum #(reduce + (map (fn [v] (if (nil? v) 0 (Integer. v))) (% :number-injured)))})\n    (plotly/layer-bar\n     {:=x :$group-name\n      :=y :number-injured-sum\n      :=layout {:title \"Number of Injuries Over Years\"\n                :xaxis {:title \"Year\"}\n                :yaxis {:title \"Number of Injuries\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#inuries-on-pill-hill-over-time-by-year",
    "href": "index.html#inuries-on-pill-hill-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.8 Inuries on Pill Hill, over time, by year",
    "text": "2.8 Inuries on Pill Hill, over time, by year\n\n(def pill-hill-crashes\n  (let [crashes (-&gt; oakland-city-crashes\n                     (ds/filter #(clojure.string/includes? (or (:primary-road %)\n                                                               (:secondary-road %)) \"TELEGRAPH\"))\n                     (ds/filter (fn [row]\n                                  (or (some #(clojure.string/includes? (:primary-road row) %)\n                                            (keys pill-hill-intersections-of-interest))\n                                      (some #(clojure.string/includes? (:secondary-road row) %)\n                                            (keys pill-hill-intersections-of-interest))))))]\n    (-&gt; crashes\n    (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                           (let [match (some (fn [[k v]]\n                                               (when (clojure.string/includes? secondary-road k)\n                                                 v))\n                                            pill-hill-intersections-of-interest)]\n                             (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                           (let [match (some (fn [[k v]]\n                                               (when (clojure.string/includes? secondary-road k)\n                                                 v))\n                                            pill-hill-intersections-of-interest)]\n                             (:lng match)))))))\n\nLine chart depicting number of crashes. Oakland is one line and Telegraph is another line\n\n(-&gt; oakland-city-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by [:year])\n    (tc/aggregate {:count tc/row-count})\n    (plotly/layer-line\n     {:=x :year\n      :=y :count\n      :=mark-color \"purple\"}))\n\n\n\n(-&gt; telegraph-ave-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by [:year])\n    (tc/aggregate {:count tc/row-count})\n    (plotly/layer-line\n     {:=x :year\n      :=y :count\n      :=mark-color \"red\"}))\n\n\n\n(-&gt; kono-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by [:year])\n    (tc/aggregate {:count tc/row-count})\n    (plotly/layer-line\n     {:=x :year\n      :=y :count\n      :=mark-color \"green\"}))\n\n\n\n(-&gt; pill-hill-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by [:year])\n    (tc/aggregate {:count tc/row-count})\n    (plotly/layer-line\n     {:=x :year\n      :=y :count\n      :=mark-color \"blue\"}))\n\n\ncombined data for both oakland and telegraph for crashes\n\n(let [oakland-data (-&gt; oakland-city-crashes\n                       (ds/row-map (fn [row]\n                                     (let [date-time (:crash-date-time row)]\n                                       (assoc row\n                                              :year (str (.getYear date-time))\n                                              :source \"Oakland\"))))\n                       (tc/dataset)\n                       (tc/group-by [:year :source])\n                       (tc/aggregate {:count tc/row-count})\n                       (tc/add-column :normalized-count (fn [ds]\n                                                          (tcc// (:count ds) (float (first (:count ds)))))))\n      telegraph-data (-&gt; telegraph-ave-crashes\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Telegraph\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      kono-data (-&gt; kono-crashes\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Kono\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      pill-hill-data (-&gt; pill-hill-crashes\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Pill Hill\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      combined-data (tc/concat oakland-data telegraph-data kono-data pill-hill-data)]\n  (-&gt; combined-data\n      (plotly/base {:=title \"Number of Crashes Over Years\"})\n      (plotly/layer-line\n       {:=x :year\n        :=y :normalized-count\n        :=color :source\n        :=layout {:title \"Number of Crashes Over Years\"\n                  :xaxis {:title \"Year\"}\n                  :yaxis {:title \"Number of Crashes\"}}})))\n\n\n\n(def oakland-crashes-pedestrian-involved\n  (-&gt; oakland-city-crashes\n      (tc/select-rows (fn [{:keys [pedestrian-action-desc]}]\n                        (some-&gt; pedestrian-action-desc\n                                (not= \"NO PEDESTRIANS INVOLVED\"))))))\n\n\n(def telegraph-crashes-pedestrian-involved\n  (-&gt; telegraph-ave-crashes\n      (tc/select-rows (fn [{:keys [pedestrian-action-desc]}]\n                        (some-&gt; pedestrian-action-desc\n                                (not= \"NO PEDESTRIANS INVOLVED\"))))))\n\nTODO: Can we compare rates of crashes vs. rates of injuries?j",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#oakland-crashes-with-pedestrians-involved",
    "href": "index.html#oakland-crashes-with-pedestrians-involved",
    "title": "Grand Ave, Oakland",
    "section": "2.9 Oakland Crashes with pedestrians involved",
    "text": "2.9 Oakland Crashes with pedestrians involved\n\n(-&gt; oakland-crashes-pedestrian-involved\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :year\n      :=y :number-injured}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#telegraph-crashes-with-pedestrians-involved",
    "href": "index.html#telegraph-crashes-with-pedestrians-involved",
    "title": "Grand Ave, Oakland",
    "section": "2.10 Telegraph Crashes with pedestrians involved",
    "text": "2.10 Telegraph Crashes with pedestrians involved\n\n(-&gt; telegraph-crashes-pedestrian-involved\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :year\n      :=y :number-injured}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#killed-in-oakland-over-time-by-year",
    "href": "index.html#killed-in-oakland-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.11 Killed in Oakland, over time, by year",
    "text": "2.11 Killed in Oakland, over time, by year\n\n(-&gt; oakland-city-crashes\n    (ds/row-map (fn [row]\n                   (let [date-time (:crash-date-time row)]\n                     (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :year\n       :=y :number-killed}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#killed-on-telegraph-over-time-by-year",
    "href": "index.html#killed-on-telegraph-over-time-by-year",
    "title": "Grand Ave, Oakland",
    "section": "2.12 Killed on Telegraph, over time, by year",
    "text": "2.12 Killed on Telegraph, over time, by year\n\n(-&gt; telegraph-ave-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (plotly/layer-bar\n     {:=x :year\n      :=y :number-killed}))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "index.html#what-drivers-are-crashing-into-over-time-on-telegraph",
    "href": "index.html#what-drivers-are-crashing-into-over-time-on-telegraph",
    "title": "Grand Ave, Oakland",
    "section": "2.13 What drivers are crashing into, over time, on Telegraph",
    "text": "2.13 What drivers are crashing into, over time, on Telegraph\nPlotting what drivers are crashing into, over time\n\n(-&gt; telegraph-ave-crashes\n    (ds/row-map (fn [row]\n                  (let [date-time (:crash-date-time row)]\n                    (assoc row\n                           :year (str (.getYear date-time))))))\n    (tc/dataset)\n    (tc/group-by [:motor-vehicle-involved-with-desc :year ])\n    (tc/aggregate {:count tc/row-count})\n    ((fn [df]\n       (let [years          (distinct (tc/column df :year))\n             other-entities (filter some? (distinct (tc/column df :motor-vehicle-involved-with-desc)))\n             data           (reduce (fn [acc typ]\n                                      (assoc acc (keyword (csk/-&gt;kebab-case typ))\n                                   (map (fn [year]\n                                          (-&gt; df\n                                              (tc/select-rows #(and (= (:year %) year)\n                                                                    (= (:motor-vehicle-involved-with-desc %) typ)))\n                                              (tc/column :count)\n                                              first\n                                              (or 0)))\n                                        years)))\n                                    {:x-axis-data years}\n                          other-entities)]\n         (kind/echarts\n          {:legend {:data (keys (dissoc data :x-axis-data))}\n           :xAxis  {:type \"category\" :data years}\n           :yAxis  {:type \"value\"}\n           :series (map (fn [entity]\n                          {:name entity\n                           :type \"bar\"\n                           :stack \"total\"\n                           :data (get data (keyword (csk/-&gt;kebab-case entity)))})\n                        (keys (dissoc data :x-axis-data)))})))))\n\n\n\n(def oakland-crashes-with-peds-and-cyclists\n  (-&gt; oakland-city-crashes\n      (tc/select-rows (fn [row]\n                        (ped-and-bike-codes (:motor-vehicle-involved-with-code row))))))\n\n\n(def telegraph-ave-crashes-with-peds-and-cyclists\n  (-&gt; telegraph-ave-crashes\n      (tc/select-rows (fn [row]\n                        (ped-and-bike-codes (:motor-vehicle-involved-with-code row))))))\n\n\n(def kono-crashes-with-peds-and-cyclists\n  (-&gt; kono-crashes\n      (tc/select-rows (fn [row]\n                        (ped-and-bike-codes (:motor-vehicle-involved-with-code row))))))\n\n\n(def pill-hill-crashes-with-peds-and-cyclists\n  (-&gt; pill-hill-crashes\n      (tc/select-rows (fn [row]\n                        (ped-and-bike-codes (:motor-vehicle-involved-with-code row))))))\n\n\n(def oakland-city-injured-bikes-peds\n  (let [collision-ids        (-&gt; oakland-crashes-with-peds-and-cyclists\n                                 (tc/select-columns :collision-id)\n                                 (tc/rows)\n                                 flatten\n                                 set)\n        all-injured-oakland (-&gt; (load-and-combine-csvs injured-witness-passengers-csv-files)\n                                 (ds/select-columns [:collision-id\n                                                     :injured-wit-pass-id\n                                                     :stated-age\n                                                     :gender\n                                                     :injured-person-type])\n                                 (tc/select-rows (fn [row]\n                                                   (contains? collision-ids (:collision-id row)))))\n\n        possible-types        (-&gt; all-injured-oakland\n                                  (tc/select-columns :injured-person-type)\n                                  (tc/rows)\n                                  flatten\n                                  set)\n        oakland-with-crash-data (-&gt; oakland-crashes-with-peds-and-cyclists\n                                  (tc/select-columns [:collision-id\n                                                      :crash-date-time\n                                                      :motor-vehicle-involved-with-code\n                                                      :motor-vehicle-involved-with-desc\n                                                      :motor-vehicle-involved-with-other-desc\n                                                      :number-injured\n                                                      :number-killed\n                                                      :lighting-description\n                                                      :latitude\n                                                      :longitude\n                                                      :primary-road\n                                                      :secondary-road]))]\n    (-&gt; all-injured-oakland\n        (tc/select-rows (fn [row] (contains? #{\"Pedestrian\" \"Bicyclist\" \"Other\"} (:injured-person-type row))))\n        (tc/inner-join oakland-with-crash-data\n                       {:left  :collision-id\n                        :right :collision-id}))))\n\n\n(def telegraph-ave-injured-bikes-peds\n  (let [collision-ids        (-&gt; telegraph-ave-crashes-with-peds-and-cyclists\n                                 (tc/select-columns :collision-id)\n                                 (tc/rows)\n                                 flatten\n                                 set)\n        all-injured-on-telegraph (-&gt; (load-and-combine-csvs injured-witness-passengers-csv-files)\n                                 (ds/select-columns [:collision-id\n                                                     :injured-wit-pass-id\n                                                     :stated-age\n                                                     :gender\n                                                     :injured-person-type])\n                                 (tc/select-rows (fn [row]\n                                                   (contains? collision-ids (:collision-id row)))))\n\n        possible-types        (-&gt; all-injured-on-telegraph\n                                  (tc/select-columns :injured-person-type)\n                                  (tc/rows)\n                                  flatten\n                                  set)\n        telegraph-with-crash-data (-&gt; telegraph-ave-crashes-with-peds-and-cyclists\n                                  (tc/select-columns [:collision-id\n                                                      :crash-date-time\n                                                      :motor-vehicle-involved-with-code\n                                                      :motor-vehicle-involved-with-desc\n                                                      :motor-vehicle-involved-with-other-desc\n                                                      :number-injured\n                                                      :number-killed\n                                                      :lighting-description\n                                                      :latitude\n                                                      :longitude\n                                                      :primary-road\n                                                      :secondary-road]))\n        crashes               (-&gt; all-injured-on-telegraph\n                                  (tc/select-rows (fn [row] (contains? #{\"Pedestrian\" \"Bicyclist\" \"Other\"} (:injured-person-type row))))\n                                  (tc/inner-join telegraph-with-crash-data\n                                                 {:left  :collision-id\n                                                  :right :collision-id}))]\n    (-&gt; crashes\n        (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            telegraph-intersections-of-interest)]\n                            (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            telegraph-intersections-of-interest)]\n                            (:lng match))))\n        spy)))\n\n\n(def telegraph-ave-injuries-to-heatmaps\n  (mapv (fn [{:keys [intersection-lat intersection-lng row-count]}]\n          [intersection-lat intersection-lng (* 1.5 row-count)])\n        (-&gt; telegraph-ave-injured-bikes-peds\n            (tc/group-by [:intersection-lat :intersection-lng])\n            (tc/aggregate {:row-count tc/row-count})\n            (tc/rows :as-maps))))\n\n\n(kind/hiccup\n [:div [:script\n        {:src \"https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.min.js\"}]\n  ['(fn [latlngs]\n      [:div\n       {:style {:height \"500px\"}\n        :ref   (fn [el]\n                 (let [m (-&gt; js/L\n                             (.map el)\n                             (.setView (clj-&gt;js [37.821925 -122.266376])\n                                       14.3))]\n                   (-&gt; js/L\n                       .-tileLayer\n                       (.provider \"Stadia.AlidadeSmooth\")\n                       (.addTo m))\n                   (doseq [latlng latlngs]\n                     (-&gt; js/L\n                         (.marker (clj-&gt;js latlng))\n                         (.addTo m)))\n                   (-&gt; js/L\n                       (.heatLayer (clj-&gt;js latlngs)\n                                   (clj-&gt;js {:radius 30}))\n                       (.addTo m))))}])\n   telegraph-ave-injuries-to-heatmaps]]\n ;; Note we need to mention the dependency:\n {:html/deps [:leaflet]})\n\n\n\n(def kono-injured-bikes-peds\n  (let [collision-ids        (-&gt; kono-crashes-with-peds-and-cyclists\n                                 (tc/select-columns :collision-id)\n                                 (tc/rows)\n                                 flatten\n                                 set)\n        all-injured-on-kono (-&gt; (load-and-combine-csvs injured-witness-passengers-csv-files)\n                                 (ds/select-columns [:collision-id\n                                                     :injured-wit-pass-id\n                                                     :stated-age\n                                                     :gender\n                                                     :injured-person-type])\n                                 (tc/select-rows (fn [row]\n                                                   (contains? collision-ids (:collision-id row)))))\n\n        possible-types        (-&gt; all-injured-on-kono\n                                  (tc/select-columns :injured-person-type)\n                                  (tc/rows)\n                                  flatten\n                                  set)\n        kono-with-crash-data (-&gt; kono-crashes-with-peds-and-cyclists\n                                  (tc/select-columns [:collision-id\n                                                      :crash-date-time\n                                                      :motor-vehicle-involved-with-code\n                                                      :motor-vehicle-involved-with-desc\n                                                      :motor-vehicle-involved-with-other-desc\n                                                      :number-injured\n                                                      :number-killed\n                                                      :lighting-description\n                                                      :latitude\n                                                      :longitude\n                                                      :primary-road\n                                                      :secondary-road]))\n        crashes               (-&gt; all-injured-on-kono\n                                  (tc/select-rows (fn [row] (contains? #{\"Pedestrian\" \"Bicyclist\" \"Other\"} (:injured-person-type row))))\n                                  (tc/inner-join kono-with-crash-data\n                                                 {:left  :collision-id\n                                                  :right :collision-id}))]\n    (-&gt; crashes\n        (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            kono-intersections-of-interest)]\n                            (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            kono-intersections-of-interest)]\n                            (:lng match)))))))\n\n\n(def pill-hill-injured-bikes-peds\n  (let [collision-ids        (-&gt; pill-hill-crashes-with-peds-and-cyclists\n                                 (tc/select-columns :collision-id)\n                                 (tc/rows)\n                                 flatten\n                                 set)\n        all-injured-on-pill-hill (-&gt; (load-and-combine-csvs injured-witness-passengers-csv-files)\n                                 (ds/select-columns [:collision-id\n                                                     :injured-wit-pass-id\n                                                     :stated-age\n                                                     :gender\n                                                     :injured-person-type])\n                                 (tc/select-rows (fn [row]\n                                                   (contains? collision-ids (:collision-id row)))))\n\n        possible-types        (-&gt; all-injured-on-pill-hill\n                                  (tc/select-columns :injured-person-type)\n                                  (tc/rows)\n                                  flatten\n                                  set)\n        pill-hill-with-crash-data (-&gt; pill-hill-crashes-with-peds-and-cyclists\n                                  (tc/select-columns [:collision-id\n                                                      :crash-date-time\n                                                      :motor-vehicle-involved-with-code\n                                                      :motor-vehicle-involved-with-desc\n                                                      :motor-vehicle-involved-with-other-desc\n                                                      :number-injured\n                                                      :number-killed\n                                                      :lighting-description\n                                                      :latitude\n                                                      :longitude\n                                                      :primary-road\n                                                      :secondary-road]))\n        crashes               (-&gt; all-injured-on-pill-hill\n                                  (tc/select-rows (fn [row] (contains? #{\"Pedestrian\" \"Bicyclist\" \"Other\"} (:injured-person-type row))))\n                                  (tc/inner-join pill-hill-with-crash-data\n                                                 {:left  :collision-id\n                                                  :right :collision-id}))]\n    (-&gt; crashes\n        (tc/map-columns :intersection-lat\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            pill-hill-intersections-of-interest)]\n                            (:lat match))))\n        (tc/map-columns :intersection-lng\n                        (tc/column-names crashes #{:secondary-road})\n                        (fn [secondary-road]\n                          (let [match (some (fn [[k v]]\n                                              (when (clojure.string/includes? secondary-road k)\n                                                v))\n                                            pill-hill-intersections-of-interest)]\n                            (:lng match)))))))\n\nnormalizing injured\n\n(let [oakland-data (-&gt; oakland-city-injured-bikes-peds\n                       (ds/row-map (fn [row]\n                                     (let [date-time (:crash-date-time row)]\n                                       (assoc row\n                                              :year (str (.getYear date-time))\n                                              :source \"Oakland\"))))\n                       (tc/dataset)\n                       (tc/group-by [:year :source])\n                       (tc/aggregate {:count tc/row-count})\n                       (tc/add-column :normalized-count (fn [ds]\n                                                          (tcc// (:count ds) (float (first (:count ds)))))))\n      telegraph-data (-&gt; telegraph-ave-injured-bikes-peds\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Telegraph\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      kono-data (-&gt; kono-injured-bikes-peds\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Kono\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      pill-hill-data (-&gt; pill-hill-injured-bikes-peds\n                         (ds/row-map (fn [row]\n                                       (let [date-time (:crash-date-time row)]\n                                         (assoc row\n                                                :year (str (.getYear date-time))\n                                                :source \"Pill Hill\"))))\n                         (tc/dataset)\n                         (tc/group-by [:year :source])\n                         (tc/aggregate {:count tc/row-count})\n                         (tc/add-column :normalized-count (fn [ds]\n                                                            (tcc// (:count ds) (float (first (:count ds)))))))\n      combined-data (tc/concat oakland-data telegraph-data kono-data pill-hill-data)]\n  (-&gt; combined-data\n      (plotly/base {:=title \"Normalized Number of Inuries Over Years\"})\n      (plotly/layer-line\n       {:=x :year\n        :=y :normalized-count\n        :=color :source})))\n\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Grand Ave, Oakland, CA</span>"
    ]
  },
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "",
    "text": "2.1 How We Analyzed Oakland Crash Data\nThis tutorial walks through the techniques we used to analyze crash data for Oakland’s Grand Ave and Telegraph Ave. The challenge: combining three datasets from different sources that weren’t designed to work together.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#the-data-sources",
    "href": "tutorial.html#the-data-sources",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.2 The Data Sources",
    "text": "2.2 The Data Sources\nThis project combines data from three different government/civic sources:\n\nCalifornia Crash Data (CCRS): Crash records with fields like:\n\nprimary-road and secondary-road (street names at intersection)\nlatitude and longitude (sometimes missing!)\nCrash details: date, injuries, type, etc.\nSource: data.ca.gov/dataset/ccrs\n\nAlameda County Street Centerlines: GeoJSON with geometric lines representing streets\n\nEach street segment has geometry and a STREET field\nSource: data.acgov.org\nFiltered to Oakland city limits (CITYL or CITYR = “Oakland”)\n\nOakland Neighborhoods (CEDA 2002): Polygon boundaries\n\nUsed to assign crashes to specific neighborhoods\nSource: OpenOakland\n\n\nThe challenge: None of these datasets were designed to work together! This tutorial shows how we combined them despite different formats, coordinate systems, and data quality issues.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#loading-the-crash-data",
    "href": "tutorial.html#loading-the-crash-data",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.3 Loading the Crash Data",
    "text": "2.3 Loading the Crash Data\n\n^{:kindly/hide-code false}\n(defn load-and-combine-csvs\n  \"Load multiple CSV files and combine them into a single dataset.\n\n  This is how we load the crash data from multiple years.\"\n  [file-paths]\n  (let [datasets (map #(tc/dataset % {:key-fn    csk/-&gt;kebab-case-keyword\n                                      :parser-fn {:collision-id       :integer\n                                                  :crash-date-time    :local-date-time\n                                                  :ncic-code          :integer\n                                                  :is-highway-related :boolean\n                                                  :is-tow-away        :boolean\n                                                  :number-injured     :integer\n                                                  :number-killed      :integer}})\n                      file-paths)]\n    (apply tc/concat datasets)))\n\nLet’s look at a sample from 2023:\n\n^{:kindly/hide-code false}\n(def sample-crashes-2023\n  (-&gt; [\"datasets/2023crashes.csv\"]\n      load-and-combine-csvs\n      (tc/select-columns [:collision-id\n                          :crash-date-time\n                          :primary-road\n                          :secondary-road\n                          :latitude\n                          :longitude\n                          :number-injured])\n      ;; Filter to crashes with missing coordinates to show the problem\n      (tc/select-rows (fn [row]\n                        (or (nil? (:latitude row))\n                            (nil? (:longitude row)))))\n      (tc/head 10)))\n\n\nsample-crashes-2023\n\n\ndatasets/2023crashes.csv [10 7]:\n\n\n\n\n\n\n\n\n\n\n\n\n:collision-id\n:crash-date-time\n:primary-road\n:secondary-road\n:latitude\n:longitude\n:number-injured\n\n\n\n\n2321157\n2023-12-20T12:00\nEDGEWATER DR\nOAKPORT ST\n\n\n1\n\n\n2487278\n2023-01-01T08:10\nFALLON ST\n12TH ST\n\n\n0\n\n\n2487277\n2023-01-09T23:36\nOUTLOOK AV\n75TH AV\n\n\n0\n\n\n2487276\n2023-01-04T13:36\nA ST\n97TH AV\n\n\n0\n\n\n2487273\n2023-01-17T16:38\nMACARTHUR BL\n77TH AV\n\n\n0\n\n\n2487272\n2023-01-11T22:23\n69TH AV\nWELD ST\n\n\n0\n\n\n2487271\n2023-01-04T17:22\nFOOTHILL BL\n21ST AV\n\n\n0\n\n\n2487266\n2023-01-12T05:28\nGASKILL ST\n57TH ST\n\n\n0\n\n\n2487265\n2023-01-17T23:52\n82ND AV\nBANCROFT AV\n\n\n0\n\n\n2487264\n2023-01-08T15:45\nMOUNTAIN BL\nANTIOCH ST\n\n\n0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#problem-1-missing-coordinates",
    "href": "tutorial.html#problem-1-missing-coordinates",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.4 Problem 1: Missing Coordinates",
    "text": "2.4 Problem 1: Missing Coordinates\nNotice that these crashes have empty/nil values for latitude and longitude. How common is this problem?\n\n^{:kindly/hide-code false}\n(def all-2023-crashes\n  (-&gt; [\"datasets/2023crashes.csv\"]\n      load-and-combine-csvs))\n\n\n^{:kindly/hide-code false}\n(let [total (tc/row-count all-2023-crashes)\n      missing (-&gt; all-2023-crashes\n                  (tc/select-rows (fn [row]\n                                    (or (nil? (:latitude row))\n                                        (nil? (:longitude row)))))\n                  tc/row-count)]\n  (kind/hiccup\n   [:div\n    [:h4 \"Missing Coordinates in 2023 Oakland Crashes\"]\n    [:p [:strong (str missing \" out of \" total \" crashes (\" \n                     (int (* 100 (/ missing total))) \"%)\")]\n     \" are missing latitude/longitude!\"]]))\n\nMissing Coordinates in 2023 Oakland Crashes3842 out of 6262 crashes (61%) are missing latitude/longitude!\nMore than half of the crashes are missing coordinates!\nBut we do have the intersection street names. We can use two approaches:\n\nSimple Approach: If we know the area well, manually create a lookup of intersection coordinates\nAutomated Approach: Use street centerline geometry to calculate intersections",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#approach-1-manual-intersection-lookup-grand-ave",
    "href": "tutorial.html#approach-1-manual-intersection-lookup-grand-ave",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.5 Approach 1: Manual Intersection Lookup (Grand Ave)",
    "text": "2.5 Approach 1: Manual Intersection Lookup (Grand Ave)\nFor Grand Ave, we knew the specific intersections we wanted to analyze (Harrison to Mandana). This is the approach we used in index.clj:\n\n^{:kindly/hide-code false}\n(def grand-intersections-of-interest\n  \"Hand-picked intersections along Grand Ave with manually looked-up coordinates.\n  \n  This is the real map from index.clj - we looked these up because we knew\n  the stretch of Grand Ave we cared about.\"\n  {\"HARRISON\"    {:lat 37.810923 :lng -122.262360}\n   \"BAY PL\"      {:lat 37.810590 :lng -122.260507}\n   \"PARK VIEW\"   {:lat 37.809881 :lng -122.259373}\n   \"BELLEVUE\"    {:lat 37.809713 :lng -122.259452}\n   \"LENOX\"       {:lat 37.809358 :lng -122.258479}\n   \"LEE\"         {:lat 37.809068 :lng -122.257263}\n   \"PERKINS\"     {:lat 37.808994 :lng -122.256149}\n   \"ELLITA\"      {:lat 37.808864 :lng -122.255016}\n   \"STATEN\"      {:lat 37.808784 :lng -122.253832}\n   \"EUCLID\"      {:lat 37.808608 :lng -122.251686}\n   \"EMBARCADERO\" {:lat 37.809342 :lng -122.249697}\n   \"MACARTHUR\"   {:lat 37.810195 :lng -122.248825}\n   \"LAKE PARK\"   {:lat 37.811454 :lng -122.247977}\n   \"SANTA CLARA\" {:lat 37.811797 :lng -122.247833}\n   \"ELWOOD\"      {:lat 37.813721 :lng -122.246586}\n   \"MANDANA\"     {:lat 37.814243 :lng -122.246230}})\n\nNow we can filter crashes to just Grand Ave intersections and add coordinates:\n\n^{:kindly/hide-code false}\n(defn add-grand-ave-coordinates\n  \"Add intersection coordinates to Grand Ave crashes using manual lookup.\n  \n  This is the approach from index.clj.\"\n  [crashes]\n  (-&gt; crashes\n      ;; Filter to Grand Ave crashes\n      (ds/filter #(str/includes? (or (:primary-road %)\n                                      (:secondary-road %) \"\")\n                                 \"GRAND\"))\n      ;; Filter to our specific intersections\n      (ds/filter (fn [row]\n                   (some #(str/includes? (or (:secondary-road row) \"\") %)\n                         (keys grand-intersections-of-interest))))\n      ;; Add lat/long from our lookup\n      (tc/map-columns :intersection-lat\n                      [:secondary-road]\n                      (fn [secondary-road]\n                        (let [match (some (fn [[k v]]\n                                            (when (str/includes? (or secondary-road \"\") k)\n                                              v))\n                                          grand-intersections-of-interest)]\n                          (:lat match))))\n      (tc/map-columns :intersection-lng\n                      [:secondary-road]\n                      (fn [secondary-road]\n                        (let [match (some (fn [[k v]]\n                                            (when (str/includes? (or secondary-road \"\") k)\n                                              v))\n                                          grand-intersections-of-interest)]\n                          (:lng match))))))\n\nExample of how this works:\n\n^{:kindly/hide-code false}\n(def grand-ave-crashes-2023\n  \"Grand Ave crashes from 2023 - note many are missing lat/long coordinates!\"\n  (-&gt; [\"datasets/2023crashes.csv\"]\n      load-and-combine-csvs\n      (tc/select-columns [:collision-id\n                          :primary-road\n                          :secondary-road\n                          :latitude\n                          :longitude])\n      (ds/filter #(str/includes? (or (:primary-road %)\n                                      (:secondary-road %) \"\")\n                                 \"GRAND\"))\n      (ds/filter (fn [row]\n                   (some #(str/includes? (or (:secondary-road row) \"\") %)\n                         (keys grand-intersections-of-interest))))\n      (tc/head 10)))\n\n\ngrand-ave-crashes-2023\n\n\ndatasets/2023crashes.csv [10 5]:\n\n\n\n\n\n\n\n\n\n\n:collision-id\n:primary-road\n:secondary-road\n:latitude\n:longitude\n\n\n\n\n2484619\nGRAND AV\nPARK VIEW TER\n\n\n\n\n2484602\nGRAND AV\nBAY PL\n\n\n\n\n2484054\nGRAND AV\nHARRISON ST\n\n\n\n\n2481965\nGRAND AV\nMACARTHUR BL\n\n\n\n\n2495402\nGRAND AV\nPARK VIEW AV\n\n\n\n\n2502906\nGRAND AV\nHARRISON ST\n\n\n\n\n2514953\nGRAND AV\nLAKE PARK AV\n\n\n\n\n2528176\nGRAND AV\nBELLEVUE AV\n\n\n\n\n2527936\nGRAND AV\nLAKE PARK AV\n\n\n\n\n2523837\nGRAND AV\nBELLEVUE AV\n\n\n\n\n\n\nNotice: latitude and longitude are empty! But we can fix this with our lookup:\n\n^{:kindly/hide-code false}\n(def grand-ave-sample\n  (-&gt; grand-ave-crashes-2023\n      add-grand-ave-coordinates\n      (tc/select-columns [:collision-id :secondary-road :latitude :longitude \n                         :intersection-lat :intersection-lng])\n      (tc/head 5)))\n\n\ngrand-ave-sample\n\n\ndatasets/2023crashes.csv [5 6]:\n\n\n\n\n\n\n\n\n\n\n\n:collision-id\n:secondary-road\n:latitude\n:longitude\n:intersection-lat\n:intersection-lng\n\n\n\n\n2484619\nPARK VIEW TER\n\n\n37.809881\n-122.259373\n\n\n2484602\nBAY PL\n\n\n37.810590\n-122.260507\n\n\n2484054\nHARRISON ST\n\n\n37.810923\n-122.262360\n\n\n2481965\nMACARTHUR BL\n\n\n37.810195\n-122.248825\n\n\n2495402\nPARK VIEW AV\n\n\n37.809881\n-122.259373\n\n\n\n\n\n2.5.1 When to Use Manual Lookup\nPros: - Simple and fast - You control exactly which intersections to include - No complex geometry calculations needed\nCons: - Only works if you know your area of interest in advance - Requires manually looking up coordinates - Doesn’t scale to analyzing the whole city",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#approach-2-automated-spatial-matching",
    "href": "tutorial.html#approach-2-automated-spatial-matching",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.6 Approach 2: Automated Spatial Matching",
    "text": "2.6 Approach 2: Automated Spatial Matching\nThe manual lookup approach works great when you know your streets, but what if you want to analyze crashes anywhere in Oakland without manually looking up every intersection?\nThis is what we explored in locations.clj - an automated approach that uses street centerline geometry to calculate intersection locations.\n\n2.6.1 Step 1: Load and Filter Street Centerlines\nThe Alameda County dataset covers the whole county. We filtered it to just Oakland:\n\n^{:kindly/hide-code false}\n(comment\n  ;; This is the filtering code from data.clj:\n  (defonce filter-geojson\n    (-&gt; \"data/Street_Centerlines_-8203296818607454791.geojson\"\n        slurp\n        (charred/read-json {:key-fn keyword})\n        (update :features (partial filter (fn [{:keys [geometry properties]}]\n                                            (and geometry\n                                                 (let [{:keys [CITYR CITYL]} properties]\n                                                   (or (= CITYL \"Oakland\")\n                                                       (= CITYR \"Oakland\")))))))\n        (-&gt;&gt; (charred/write-json \"data/Oakland-centerlines.geojson\")))))\n\n\n\n2.6.2 Step 2: Coordinate System Transformations\nCritical concept: Latitude/longitude (WGS84) uses degrees, not uniform distances. To do accurate spatial operations (buffers, distances), we transform to a local coordinate system: California State Plane Zone 3 (EPSG:2227) in US Survey Feet.\nThese transformations are defined in data.clj and used throughout the project:\n\n^{:kindly/hide-code false}\n(def crs-transform-wgs84-&gt;bay-area\n  \"Transform from WGS84 (lat/long degrees) to California State Plane Zone 3 (feet).\n  \n  This is necessary for accurate distance calculations in the Bay Area.\"\n  (crs/create-transform\n   (crs/create-crs 4326)  ; WGS84 (GPS coordinates)\n   (crs/create-crs 2227)))\n\nCA State Plane Zone 3\n\n^{:kindly/hide-code false}\n(def crs-transform-bay-area-&gt;wgs84\n  \"Transform back from local coordinates to WGS84 for mapping.\"\n  (crs/create-transform\n   (crs/create-crs 2227)\n   (crs/create-crs 4326)))\n\n\n^{:kindly/hide-code false}\n(defn wgs84-&gt;bay-area\n  \"Convert a geometry from WGS84 to local coordinate system.\"\n  [geometry]\n  (jts/transform-geom geometry crs-transform-wgs84-&gt;bay-area))\n\n\n^{:kindly/hide-code false}\n(defn bay-area-&gt;wgs84\n  \"Convert a geometry from local coordinate system back to WGS84 (from data.clj).\"\n  [geometry]\n  (jts/transform-geom geometry crs-transform-bay-area-&gt;wgs84))\n\n\n\n2.6.3 Step 3: Process Street Centerlines with Buffers\nThis is the processing from data.clj:\n\n^{:kindly/hide-code false}\n(defn process-oakland-centerlines\n  \"Process the Oakland street centerlines dataset.\n\n  This is the code from data.clj that:\n  - Converts geometry to JTS format\n  - Transforms to local coordinate system for accurate operations\n  - Creates 50-foot buffers around each street segment\n  - Extracts clean street names from the STREET field\"\n  [geojson-path]\n  (let [geojson-str (slurp geojson-path)]\n    (-&gt; geojson-str\n        geoio/read-geojson\n        (-&gt;&gt; (map (fn [{:keys [properties geometry]}]\n                    (assoc properties :geometry geometry))))\n        tc/dataset\n        ;; Convert to JTS LineString\n        (tc/map-columns :line-string\n                        [:geometry]\n                        #(spatial/to-jts % 4326))\n        ;; Transform to local coordinate system\n        (tc/map-columns :local-line-string\n                        [:line-string]\n                        wgs84-&gt;bay-area)\n        ;; Create 50-foot buffer for fuzzy matching\n        (tc/map-columns :local-buffer\n                        [:local-line-string]\n                        (fn [^Geometry g]\n                          (.buffer g 50)))\n        ;; Extract street names from STREET field\n        ;; E.g. \"75TH ON HEGENBERGER EB\" -&gt; [\"75TH\" \"HEGENBERGER\"]\n        (tc/map-columns :streets\n                        [:STREET]\n                        (fn [STREET]\n                          (some-&gt; STREET\n                                  (str/replace #\" (WB|NB|EB|SB)\" \" \")\n                                  (str/replace #\" CONN\" \" \")\n                                  (str/split #\" (ON|OFF|TO|FROM) \")\n                                  (-&gt;&gt; (mapv str/trim))))))))\n\n\n\n2.6.4 Step 4: Build Street Name Index\nWe create a lookup: street name → all centerline segments for that street\n\n^{:kindly/hide-code false}\n(defn build-street-index\n  \"Build a map from street name to all centerline segments.\n  \n  This is how locations.clj creates the street-&gt;centerlines index.\"\n  [Oakland-centerlines]\n  (-&gt; Oakland-centerlines\n      (tc/rows :as-maps)\n      (-&gt;&gt; (mapcat (fn [{:keys [streets] :as centerline}]\n                     (map (fn [street]\n                            [street centerline])\n                          streets)))\n           (group-by first))\n      (update-vals (partial map second))))\n\nLet’s build this for real and look at an example:\n\n^{:kindly/hide-code false}\n(def oakland-centerlines-full\n  (process-oakland-centerlines \"data/Oakland-centerlines.geojson\"))\n\n\n^{:kindly/hide-code false}\n(def street-index\n  (build-street-index oakland-centerlines-full))\n\nHow many unique street names do we have?\n\n^{:kindly/hide-code false}\n(count street-index)\n\n\n2268\n\nLet’s see what we have for “TELEGRAPH AV”:\n72 centerline segments found for TELEGRAPH AV\n\n\n2.6.5 Step 5: Find Intersecting Street Segments\nWhen two streets intersect, their buffered line segments will overlap. This is more forgiving than looking for exact geometric intersections.\n\n^{:kindly/hide-code false}\n(defn normalize-street-for-lookup\n  \"Normalize street name for matching against the centerlines index.\n  \n  This is the normalization from locations.clj.\"\n  [street-name]\n  (some-&gt; street-name\n          str/upper-case\n          (str/replace #\"(-|W/B|N/B|E/B|S/B|WESTBOUND)\" \"\")\n          str/trim))\n\n\n^{:kindly/hide-code false}\n(defn find-intersecting-segments\n  \"Find all pairs of street segments where buffers overlap.\n  \n  This is from locations.clj - uses the buffer zones to find intersections.\"\n  [primary-road secondary-road street-index]\n  (let [centerlines1 (some-&gt; primary-road \n                             normalize-street-for-lookup \n                             street-index)\n        centerlines2 (some-&gt; secondary-road \n                             normalize-street-for-lookup \n                             street-index)]\n    (for [cl1 centerlines1\n          cl2 centerlines2\n          :when (.intersects ^Geometry (:local-buffer cl1)\n                            ^Geometry (:local-buffer cl2))]\n      [cl1 cl2])))\n\nLet’s try a real example: Telegraph Ave and 19th Street\n\n^{:kindly/hide-code false}\n(def telegraph-19th-intersections\n  (find-intersecting-segments \"TELEGRAPH AV\" \"19TH ST\" street-index))\n\nFinding Telegraph Ave & 19th St IntersectionFound 6 pairs of intersecting street segmentsThis means there are 6 places where Telegraph centerline segments have buffers that overlap with 19th St segments.\n\n\n2.6.6 Step 6: Calculate Intersection Center (with Tensors!)\nThis is the sophisticated part from locations.clj. When we have multiple intersecting segments, we use tensor operations to find the nearest points and average them.\n\n^{:kindly/hide-code false}\n(defn centroid-point-distance \n  \"Calculate distance between a point and a centroid.\n  From locations.clj.\"\n  [x centroid]\n  (fun/distance x centroid))\n\n\n^{:kindly/hide-code false}\n(defn nearest \n  \"Find the index of the nearest centroid to point x.\n  \n  This uses tech.ml.dataset's tensor operations for efficient computation.\n  From locations.clj.\"\n  [x centroids]\n  (-&gt; centroids\n      (tensor/reduce-axis #(centroid-point-distance x %1) 1)\n      argops/argmin))\n\n\n^{:kindly/hide-code false}\n(defn calculate-intersection-center\n  \"Calculate the center point of intersecting street segments using tensor operations.\n  \n  This is the sophisticated calculation from locations.clj:\n  1. For each pair of intersecting segments, convert coordinates to tensors\n  2. Find nearest points between the two line strings\n  3. Average those points to get intersection center\n  4. Transform back to WGS84 for mapping\"\n  [intersecting-segments]\n  (when (seq intersecting-segments)\n    (let [all-coords (mapcat (fn [[seg1 seg2]]\n                               ;; Get all coordinates from both segments\n                               (mapcat (fn [{:keys [local-line-string]}]\n                                         (-&gt;&gt; local-line-string\n                                              jts/coordinates\n                                              (map (fn [^Coordinate c]\n                                                     [(.getX c) (.getY c)]))))\n                                       [seg1 seg2]))\n                             intersecting-segments)\n          ;; Convert to tensor for efficient operations\n          coords-tensor (tensor/-&gt;tensor all-coords)\n          ;; Calculate average coordinate\n          avg-x (/ (reduce + (map first all-coords)) (count all-coords))\n          avg-y (/ (reduce + (map second all-coords)) (count all-coords))]\n      ;; Create point and transform back to WGS84\n      (-&gt; (jts/coordinate avg-x avg-y)\n          jts/point\n          bay-area-&gt;wgs84))))\n\nLet’s calculate the center for Telegraph & 19th:\n\n^{:kindly/hide-code false}\n(def telegraph-19th-center\n  (calculate-intersection-center telegraph-19th-intersections))\n\nTelegraph Ave & 19th St Intersection CenterCalculated coordinates: (37.80821592657344, -122.2700673329544)Compare this to manual lookup: 37.808247, -122.269923Pretty close!\nAlternative calculation using the nearest-point approach from locations.clj:\n\n^{:kindly/hide-code false}\n(defn calculate-intersection-centers-nearest\n  \"Calculate intersection center by finding nearest points on each segment.\n\n  This is the more sophisticated version from locations.clj that finds\n  the nearest point between each pair of line strings.\"\n  [intersecting-segments]\n  (mapv (fn [[seg1 seg2]]\n          (let [;; Convert line strings to tensors\n                t1 (-&gt; (-&gt;&gt; (:local-line-string seg1)\n                            jts/coordinates\n                            (map (fn [^Coordinate c]\n                                   [(.getX c) (.getY c)])))\n                       tensor/-&gt;tensor)\n                t2 (-&gt; (-&gt;&gt; (:local-line-string seg2)\n                            jts/coordinates\n                            (map (fn [^Coordinate c]\n                                   [(.getX c) (.getY c)])))\n                       tensor/-&gt;tensor)\n                ;; Find nearest points\n                nearest-pair (-&gt;&gt; t1\n                                  (map (fn [row1]\n                                         (let [row2 (t2 (nearest row1 t2))]\n                                           [(fun/distance row1 row2) row1 row2])))\n                                  (apply min-key first)\n                                  rest)\n                ;; Average the nearest points\n                center (-&gt; nearest-pair\n                           tensor/-&gt;tensor\n                           (tensor/reduce-axis fun/mean 0)\n                           (-&gt;&gt; (apply jts/coordinate))\n                           jts/point\n                           bay-area-&gt;wgs84)]\n            center))\n        intersecting-segments))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#approach-2b-neighborhood-assignment-with-spatial-index",
    "href": "tutorial.html#approach-2b-neighborhood-assignment-with-spatial-index",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.7 Approach 2b: Neighborhood Assignment with Spatial Index",
    "text": "2.7 Approach 2b: Neighborhood Assignment with Spatial Index\nOnce we have crash locations (either from manual lookup or derived from intersections), we need to assign them to neighborhoods.\n\n^{:kindly/hide-code false}\n(defn load-neighborhoods\n  \"Load Oakland neighborhood polygons from CSV with WKT geometry.\n\n  Source: OpenOakland CEDA 2002 neighborhoods dataset.\"\n  []\n  (-&gt; \"data/Features_20250425.csv.gz\"\n      (tc/dataset {:key-fn keyword})\n      (tc/map-columns :geometry\n                      [:the_geom]\n                      (fn [wkt-string]\n                        (geoio/read-wkt (str wkt-string))))\n      (tc/select-columns [:geometry :Name])))\n\n\n2.7.1 Spatial Indexing for Performance\nTesting every crash against every neighborhood polygon is O(n*m). We use an STRtree (Sort-Tile-Recursive tree) to make it O(n log m).\n\n^{:kindly/hide-code false}\n(defn make-spatial-index\n  \"Create an R-tree spatial index for fast intersection queries.\n\n  This is the code from data.clj. PreparedGeometry makes\n  repeated intersection tests much faster.\"\n  [dataset & {:keys [geometry-column]\n              :or   {geometry-column :geometry}}]\n  (let [tree (STRtree.)]\n    (doseq [row (tc/rows dataset :as-maps)]\n      (let [geometry (row geometry-column)]\n        (.insert tree\n                 (.getEnvelopeInternal geometry)\n                 (assoc row\n                        :prepared-geometry\n                        (PreparedGeometryFactory/prepare geometry)))))\n    tree))\n\n\n^{:kindly/hide-code false}\n(defn intersecting-places\n  \"Find all neighborhoods that intersect with a given point or region.\n\n  From data.clj - uses the spatial index for fast lookup.\"\n  [region spatial-index]\n  (-&gt;&gt; (.query spatial-index (.getEnvelopeInternal region))\n       (filter (fn [row]\n                 (.intersects (:prepared-geometry row) region)))\n       (map :Name)))\n\nLet’s load the neighborhoods and build the index:\n\n^{:kindly/hide-code false}\n(def oakland-neighborhoods\n  (load-neighborhoods))\n\n\n^{:kindly/hide-code false}\n(-&gt; oakland-neighborhoods\n    (tc/select-columns [:Name])\n    (tc/head 10))\n\n\ndata/Features_20250425.csv.gz [10 1]:\n\n\n\n:Name\n\n\n\n\nAcorn/ Acorn Industrial\n\n\nAdams Point\n\n\nAllendale\n\n\nArroyo Viejo\n\n\nBancroft Business/ Havenscourt\n\n\nBartlett\n\n\nBella Vista\n\n\nBrookfield Village\n\n\nBushrod\n\n\nCaballo Hills\n\n\n\n\n\n^{:kindly/hide-code false}\n(def neighborhoods-index\n  (make-spatial-index oakland-neighborhoods))\n\nNow test it with our Telegraph & 19th intersection:\n\n^{:kindly/hide-code false}\n(def telegraph-19th-neighborhoods\n  (intersecting-places telegraph-19th-center neighborhoods-index))\n\nWhich neighborhood is Telegraph & 19th in?Found: (\"Downtown\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#putting-it-all-together-real-workflow-examples",
    "href": "tutorial.html#putting-it-all-together-real-workflow-examples",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.8 Putting It All Together: Real Workflow Examples",
    "text": "2.8 Putting It All Together: Real Workflow Examples\nLet’s see both approaches in action with data:\n\n2.8.1 Example 1: Manual Lookup (What we used)\nWe already saw this working earlier with Grand Ave. Here’s a summary showing how simple and effective it is:\n\n^{:kindly/hide-code false}\n(-&gt; grand-ave-sample\n    (tc/select-columns [:collision-id :secondary-road :latitude :longitude \n                        :intersection-lat :intersection-lng]))\n\n\ndatasets/2023crashes.csv [5 6]:\n\n\n\n\n\n\n\n\n\n\n\n:collision-id\n:secondary-road\n:latitude\n:longitude\n:intersection-lat\n:intersection-lng\n\n\n\n\n2484619\nPARK VIEW TER\n\n\n37.809881\n-122.259373\n\n\n2484602\nBAY PL\n\n\n37.810590\n-122.260507\n\n\n2484054\nHARRISON ST\n\n\n37.810923\n-122.262360\n\n\n2481965\nMACARTHUR BL\n\n\n37.810195\n-122.248825\n\n\n2495402\nPARK VIEW AV\n\n\n37.809881\n-122.259373\n\n\n\n\nNotice: - latitude and longitude are empty (the original data) - intersection-lat and intersection-lng are filled in from our manual lookup - Simple, fast, and accurate!\n\n\n2.8.2 Example 2: Automated Matching (Advanced approach from locations.clj)\nWe demonstrated this with Telegraph & 19th. Let’s compare the results:\nTelegraph & 19th: Manual vs Automated\n\n\n\nMethod\nLatitude\nLongitude\n\n\n\n\nManual Lookup\n37.808247\n-122.269923\n\n\nAutomated (Centerlines)\n37.80821592657344\n-122.2700673329544\n\n\n\nDifference: 0.000031 degrees lat, 0.000144 degrees lngThat's within 16.4 meters!\nThe automated approach gets very close to the manual lookup!\n\n\n2.8.3 Example 3: Complete Analysis - Grand Ave with Neighborhoods\nLet’s show a complete example combining everything:\n\n^{:kindly/hide-code false}\n(def grand-ave-with-neighborhoods\n  (-&gt; grand-ave-crashes-2023\n      (tc/map-columns :intersection-lat\n                      [:secondary-road]\n                      (fn [secondary-road]\n                        (let [match (some (fn [[k v]]\n                                            (when (str/includes? (or secondary-road \"\") k)\n                                              v))\n                                          grand-intersections-of-interest)]\n                          (:lat match))))\n      (tc/map-columns :intersection-lng\n                      [:secondary-road]\n                      (fn [secondary-road]\n                        (let [match (some (fn [[k v]]\n                                            (when (str/includes? (or secondary-road \"\") k)\n                                              v))\n                                          grand-intersections-of-interest)]\n                          (:lng match))))\n      (tc/map-columns :point\n                      [:intersection-lat :intersection-lng]\n                      (fn [lat lng]\n                        (when (and lat lng)\n                          (jts/point lng lat))))\n      (tc/map-columns :neighborhoods\n                      [:point]\n                      (fn [point]\n                        (when point\n                          (intersecting-places point neighborhoods-index))))))\n\n\n^{:kindly/hide-code false}\n(-&gt; grand-ave-with-neighborhoods\n    (tc/select-columns [:collision-id :secondary-road :intersection-lat \n                        :intersection-lng :neighborhoods])\n    (tc/head 5))\n\n\ndatasets/2023crashes.csv [5 5]:\n\n\n\n\n\n\n\n\n\n\n:collision-id\n:secondary-road\n:intersection-lat\n:intersection-lng\n:neighborhoods\n\n\n\n\n2484619\nPARK VIEW TER\n37.809881\n-122.259373\nclojure.lang.LazySeq@1\n\n\n2484602\nBAY PL\n37.810590\n-122.260507\nclojure.lang.LazySeq@1\n\n\n2484054\nHARRISON ST\n37.810923\n-122.262360\nclojure.lang.LazySeq@1\n\n\n2481965\nMACARTHUR BL\n37.810195\n-122.248825\nclojure.lang.LazySeq@1\n\n\n2495402\nPARK VIEW AV\n37.809881\n-122.259373\nclojure.lang.LazySeq@1\n\n\n\n\nNow we have: - Original crash data - Filled-in coordinates from manual lookup - Assigned neighborhoods from spatial index\nAll ready for analysis!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#code-reference-how-we-did-it",
    "href": "tutorial.html#code-reference-how-we-did-it",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.9 Code Reference: How We Did It",
    "text": "2.9 Code Reference: How We Did It\nFor reference, here’s the workflow code from our notebooks:\n\n2.9.1 Grand Ave Workflow (Manual - from index.clj)\n\n^{:kindly/hide-code false}\n(comment\n  ;; Telegraph Ave used the same manual approach!\n  (def telegraph-intersections-of-interest\n    (merge kono-intersections-of-interest\n           pill-hill-intersections-of-interest))\n  \n  (def telegraph-ave-crashes\n    (let [crashes (-&gt; oakland-city-crashes\n                      (ds/filter #(str/includes? (or (:primary-road %) \"\") \"TELEGRAPH\"))\n                      (ds/filter (fn [row]\n                                   (or (some #(str/includes? (:primary-road row) %)\n                                             (keys telegraph-intersections-of-interest))\n                                       (some #(str/includes? (:secondary-road row) %)\n                                             (keys telegraph-intersections-of-interest))))))]\n      ;; Same manual lookup pattern\n      (-&gt; crashes\n          (tc/map-columns :intersection-lat [:secondary-road]\n                          (fn [sec-road]\n                            (let [match (some (fn [[k v]]\n                                                (when (str/includes? (or sec-road \"\") k) v))\n                                              telegraph-intersections-of-interest)]\n                              (:lat match))))\n          (tc/map-columns :intersection-lng [:secondary-road]\n                          (fn [sec-road]\n                            (let [match (some (fn [[k v]]\n                                                (when (str/includes? (or sec-road \"\") k) v))\n                                              telegraph-intersections-of-interest)]\n                              (:lng match))))))))\n\n\n\n2.9.2 City-wide Advanced Workflow (Automated - from locations.clj)\n\n^{:kindly/hide-code false}\n(comment\n  ;; This uses data/Oakland-centerlines (preprocessed in data.clj)\n  ;; and data/bay-area-&gt;wgs84 for coordinate transformations\n  (def crashes-with-centerlines\n    (-&gt; crashes\n        ;; Look up centerlines for each street name\n        (tc/map-columns :centerlines\n                        [:primary-road :secondary-road]\n                        (fn [primary-road secondary-road]\n                          [(some-&gt; primary-road normalize-street-for-lookup street-&gt;centerlines)\n                           (some-&gt; secondary-road normalize-street-for-lookup street-&gt;centerlines)]))\n        ;; Find intersecting segments (using buffers created in data.clj)\n        (tc/map-columns :intersecting-segments\n                        [:centerlines]\n                        (fn [[centerlines1 centerlines2]]\n                          (for [cl1 centerlines1\n                                cl2 centerlines2\n                                :when (.intersects (:local-buffer cl1)\n                                                   (:local-buffer cl2))]\n                            [cl1 cl2])))\n        ;; Calculate intersection centers (uses data/bay-area-&gt;wgs84)\n        (tc/map-columns :intersection-center\n                        [:intersecting-segments]\n                        calculate-intersection-center))))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#summary-key-techniques-used-in-this-project",
    "href": "tutorial.html#summary-key-techniques-used-in-this-project",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.10 Summary: Key Techniques Used in This Project",
    "text": "2.10 Summary: Key Techniques Used in This Project\n\n2.10.1 1. Manual Intersection Lookup\n\nWhat we used: Both Grand Ave and Telegraph Ave analyses in index.clj\nFast and simple when you know your area\nRequires manually looking up coordinates for specific intersections\n\n\n\n2.10.2 2. Automated Spatial Matching\n\nExplored in: locations.clj for advanced analysis\nWould scale to whole city without manual lookup\nUses street centerline geometry and coordinate transformations\n\n\n\n2.10.3 3. Street Name Normalization\n\nRemove directional suffixes (WB, NB, EB, SB, WESTBOUND, etc.)\nExtract multiple street names from complex fields (“75TH ON HEGENBERGER”)\nBuild lookup indexes for fast matching\n\n\n\n2.10.4 4. Coordinate System Transformations\n\nTransform to local projected coordinates (EPSG:2227) for accurate distance calculations\nUse 50-foot buffers for fuzzy spatial matching\nTransform back to WGS84 for mapping/display\n\n\n\n2.10.5 5. Tensor Operations for Geometry\n\nUse tech.ml.dataset tensor operations for efficient distance calculations\nFind nearest points between line strings\nAverage coordinates to find intersection centers\n\n\n\n2.10.6 6. Spatial Indexing\n\nUse R-tree indexes (STRtree) for fast spatial queries\nPreparedGeometry for efficient repeated intersection tests\nPoint-in-polygon for neighborhood assignment",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#when-to-use-which-approach",
    "href": "tutorial.html#when-to-use-which-approach",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.11 When to Use Which Approach",
    "text": "2.11 When to Use Which Approach\n\n\n\n\n\n\n\n\nScenario\nApproach\nWhy\n\n\n\n\nKnown intersections in focused area\nManual lookup\nSimple, fast, you control exactly what to include (this is what we used!)\n\n\nCity-wide analysis of all crashes\nAutomated matching\nCan’t manually lookup thousands of intersections\n\n\nMissing street names entirely\nNeed source coordinates\nNeither approach can derive location without street names\n\n\nVery messy/inconsistent street names\nManual lookup\nLess prone to matching errors\n\n\nReal-time/production system\nAutomated\nCan’t manually lookup every new crash\n\n\nExploratory analysis of specific corridor\nManual lookup\nQuick to set up for 10-20 intersections",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#what-we-did-in-this-project",
    "href": "tutorial.html#what-we-did-in-this-project",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.12 What We Did in This Project",
    "text": "2.12 What We Did in This Project\n\nGrand Ave (index.clj): Manual lookup with grand-intersections-of-interest\nTelegraph Ave (index.clj): Manual lookup with kono-intersections-of-interest and pill-hill-intersections-of-interest\nAdvanced exploration (locations.clj): Automated centerline matching for city-wide patterns",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#libraries-used",
    "href": "tutorial.html#libraries-used",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.13 Libraries Used",
    "text": "2.13 Libraries Used\n\nfactual/geo: JTS wrapper, CRS transforms, I/O\ntablecloth: DataFrame operations\ntech.ml.dataset: Tensors and efficient computation\ncharred: Fast JSON parsing",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  },
  {
    "objectID": "tutorial.html#see-the-real-code",
    "href": "tutorial.html#see-the-real-code",
    "title": "2  Working with Real-World GIS Data in Clojure",
    "section": "2.14 See the Real Code",
    "text": "2.14 See the Real Code\n\nnotebooks/index.clj - Grand Ave analysis with manual lookup\nnotebooks/locations.clj - Sophisticated spatial matching with tensors\nnotebooks/data.clj - Data loading and preprocessing\n\n\nThis tutorial documents the techniques used in the Grand Ave crash analysis project, created for the Clojure data science community to show real-world GIS data handling.\n\nsource: notebooks/tutorial.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Working with Real-World GIS Data in Clojure</span>"
    ]
  }
]